mod scope_builder;
pub mod scope_id;

use std::{
    borrow::Cow,
    future::{join, Future},
    hash::Hash,
};

use ahash::AHasher;
use dashmap::DashMap;
use diagnostics::{Diagnostic, DiagnosticLevel};
use parser::{
    ast::{
        ast::AstNode,
        node::{BlockExpr, FunctionItem, FunctionSig, Module, Path},
        visitor::{base, Visitor},
    },
    GreenNode, SyntaxNode, SyntaxNodePtr,
};
use scopeguard::guard;

#[derive(Default)]
struct ScopeBuilder {
    current: usize,
    stack: Vec<usize>,
}

impl ScopeBuilder {
    pub fn current_scope_id(&self) -> usize {
        self.current
    }
    pub fn push_scope(&mut self) -> usize {
        let current = self.current;
        self.stack.push(current);
        self.current = current + 1;
        current
    }
    pub fn pop_scope(&mut self) -> Option<usize> {
        self.stack.pop()
    }
}

#[derive(Debug, PartialEq, Eq, Hash)]
struct HirPath(SyntaxNodePtr);

interner::impl_internable!(HirPath);

struct PathId {}

struct ScopeState {
    id: usize,
}

pub struct ModuleNormaliser {
    sb: ScopeBuilder,
    root: GreenNode,
    scopes: DashMap<usize, ()>,
}

impl ModuleNormaliser {
    pub fn new(root: GreenNode) -> Self {
        Self {
            sb: ScopeBuilder::default(),
            scopes: Default::default(),
            root,
        }
    }
}

impl Visitor for ModuleNormaliser {
    fn visit_module(&mut self, module: Module) {
        self.sb.push_scope();
        let mut v = guard(self, |mn| {
            mn.sb.pop_scope();
        });
        base::visit_module(module, &mut *v)
    }

    fn visit_fn_item(&mut self, item: FunctionItem) {
        let ptr = SyntaxNodePtr::new(item.syntax());
        visit_function(ptr, self.root.clone(), self.sb.current_scope_id());
    }

    fn visit_path(&mut self, path: Path) {
        use std::hash::Hasher;

        let mut hasher = AHasher::default();
        for segment in path.segments() {
            segment.syntax().hash(&mut hasher);
        }

        let path_hash = hasher.finish();
        let path_key = (self.sb.current_scope_id(), path_hash);
    }

    fn visit_block_expr(&mut self, block: BlockExpr) {
        self.sb.push_scope();
        let mut v = guard(self, |mn| {
            mn.sb.pop_scope();
        });
        base::visit_block_expr(block, &mut *v)
    }
}

fn register_fn_signature(sig: &FunctionSig, scope_id: usize) {}

async fn visit_function(syntax_ptr: SyntaxNodePtr, root: GreenNode, scope_id: usize) {
    use futures::join;

    let signature = executor::spawn(async move {
        let root = SyntaxNode::new_root(root).into();
        let fn_item = FunctionItem::cast(syntax_ptr.to_node(&root).into()).unwrap();

        let sig = fn_item.signature();
        if let Some(sig) = sig {
            register_fn_signature(&sig, scope_id);
        } else {
            diagnostics::report(Diagnostic {
                level: DiagnosticLevel::FATAL,
                title: Cow::Borrowed("Compiler Bug"),
                message: Cow::Borrowed("Function Item did not have a signature"),
                span: fn_item.syntax().text_range(),
            });
        }
    });

    // let block = fn_item.block_expr();
    // let block_fut = executor::spawn(async move {
    //     if let Some(block) = block {
    //         // TODO
    //     } else {
    //         diagnostics::report(Diagnostic {
    //             level: DiagnosticLevel::FATAL,
    //             title: Cow::Borrowed("Compiler Bug"),
    //             message: Cow::Borrowed("Function Item did not have a body"),
    //             span: fn_item.syntax().text_range(),
    //         });
    //     };
    // });
    //
    // let (_, _) = join!(signature_fut, block_fut);
}

#[cfg(test)]
mod tests {
    use parser::{ast::node::Item, parse_source_file};
    use std::sync::Arc;

    use super::*;

    #[test]
    fn it_works() {
        let src: Arc<str> = Arc::from("fn test() {}");
        let (module, _root, _diagnostics) = parse_source_file(src.clone());

        for item in module.items() {
            match item {
                Item::Function(i) => {}
                _ => unimplemented!(),
            }
        }
    }
}
